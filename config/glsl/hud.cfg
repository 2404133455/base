///////////////////////////////////////////////////
//
// used for rendering to the HUD
//
///////////////////////////////////////////////////

shader 0 "hudrgb" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0;
        colorscale = vcolor;
    }
] [
    uniform sampler2D tex0;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    fragdata(0) vec4 fragcolor;
    void main(void)
    {
        if(colorscale.a <= 0.0) discard;
        vec4 color = texture2D(tex0, texcoord0);
        fragcolor.rgb = colorscale.rgb * color.rgb;
        fragcolor.a   = colorscale.a;
    }
]

shader 0 "hudrect" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0;
        colorscale = vcolor;
    }
] [
    uniform sampler2DRect tex0;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    fragdata(0) vec4 fragcolor;
    void main(void)
    {
        vec4 color = colorscale * texture2DRect(tex0, texcoord0);
        if(color.a <= 0.0) discard;
        fragcolor = color;
    }
]

hudvisor = [
    shader 0 $arg1 [
        attribute vec4 vvertex, vcolor;
        attribute vec2 vtexcoord0;
        uniform mat4 hudmatrix;
        varying vec2 texcoord0;
        varying vec4 colorscale;
        void main(void)
        {
            gl_Position = hudmatrix * vvertex;
            texcoord0 = vtexcoord0;
            colorscale = vcolor;
        }
    ] [
        uniform sampler2DRect tex0;
        uniform float time;
        @(? (>= (strstr $arg1 "view") 0) [
            uniform vec4 visorparams;
        ])
        uniform vec4 visorsize;
        varying vec2 texcoord0;
        varying vec4 colorscale;

        fragdata(0) vec4 fragcolor;

        float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233)))*43758.5453); }

        void main(void)
        {
            vec2 uv = texcoord0.xy;
            vec4 diffuse = vec4(0.0);

            @(if (>= (strstr $arg1 "view") 0) [result [
                // WARNING: This program MUST produce the same
                // results as the engine 'visorcoords()' for cursor projection

                uv *= visorsize.zw;

                uv -= vec2(0.5);
                uv *= visorparams.zw;

                float l = length(uv);
                uv.xy *= (1.0 + visorparams.x * visorparams.y * visorparams.y);
                uv.xy /= (1.0 + visorparams.x + l * l);

                uv += vec2(0.5);

                uv *= visorsize.xy;
            ]])

            diffuse = texture2DRect(tex0, uv);

            if(diffuse.a == 0.0) discard;

            fragcolor = colorscale * diffuse;
        }
    ]
]

hudvisor "hudvisor"
hudvisor "hudvisorview"

shader 0 "hud2d" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0;
        colorscale = vcolor;
    }
] [
    uniform sampler2D tex0;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    fragdata(0) vec4 fragcolor;
    void main(void)
    {
        vec4 color = colorscale * texture2D(tex0, texcoord0);
        if(color.a <= 0.0) discard;
        fragcolor = color;
    }
]

shader 0 "hud3d" [
    attribute vec4 vvertex, vcolor;
    attribute vec3 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec3 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0;
        colorscale = vcolor;
    }
] [
    uniform sampler3D tex0;
    varying vec3 texcoord0;
    varying vec4 colorscale;
    fragdata(0) vec4 fragcolor;
    void main(void)
    {
        vec4 color = colorscale * texture3D(tex0, texcoord0);
        if(color.a <= 0.0) discard;
        fragcolor = color;
    }
]

shader 0 "hudcubemap" [
    attribute vec4 vvertex, vcolor;
    attribute vec3 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec3 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0;
        colorscale = vcolor;
    }
] [
    uniform samplerCube tex0;
    varying vec3 texcoord0;
    varying vec4 colorscale;
    fragdata(0) vec4 fragcolor;
    void main(void)
    {
        vec4 color = colorscale * textureCube(tex0, texcoord0);
        if(color.a <= 0.0) discard;
        fragcolor = color;
    }
]

hudhalo = [
    shader 0 $arg1 [
        attribute vec4 vvertex, vcolor;
        attribute vec2 vtexcoord0;
        uniform mat4 hudmatrix;
        varying vec2 texcoord0;
        varying vec4 colorscale;

        void main(void)
        {
            gl_Position = hudmatrix * vvertex;
            texcoord0 = vtexcoord0;
            colorscale = vcolor;
        }
    ] [
        uniform sampler2DRect tex0;
        uniform vec4 halooutline;
        uniform vec3 haloinfill;
        uniform vec3 halonoise;
        uniform vec3 haloparams;
        uniform float millis;
        varying vec2 texcoord0;
        varying vec4 colorscale;
        @(gfetchdefs [tex1])

        fragdata(0) vec4 fragcolor;

        float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233)))*43758.5453); }

        vec4 getsample(sampler2DRect tex, vec2 coord, ivec2 offset, float level)
        {
            return texture2DRectOffset(tex, coord, ivec2((offset * haloparams.z) + (offset * (rand(coord + (offset * level)) - 0.5) * halonoise.x)));
        }

        void main(void)
        {
            vec4 halo = texture2DRectOffset(tex0, texcoord0, ivec2(0, 0));
            float level = (rand(vec2(millis)) - 0.5) * 2.0;
            vec4 output = halo, accum = halo;

            vec4 halo1 = getsample(tex0, texcoord0, ivec2(0, -1), level);
            if(halo1.a > output.a) output = halo1; // top
            accum += halo1;
            accum *= 0.5;

            vec4 halo2 = getsample(tex0, texcoord0, ivec2(0, 1), level);
            if(halo2.a > output.a) output = halo2; // bottom
            accum += halo2;
            accum *= 0.5;

            vec4 halo3 = getsample(tex0, texcoord0, ivec2(-1, 0), level);
            if(halo3.a > output.a) output = halo3; // left
            accum += halo3;
            accum *= 0.5;

            vec4 halo4 = getsample(tex0, texcoord0, ivec2(1, 0), level);
            if(halo4.a > output.a) output = halo4; // right
            accum += halo4;
            accum *= 0.5;

            // convert alpha back to distance
            float dist = (1.0 - output.a) * haloparams.x;

            // extract the depth information from the scene
            @(gdepthunpack depth [gfetch(tex1, gl_FragCoord.xy)])
            float maxdist = -depth;
            if(maxdist <= 0) maxdist = -gdepthunpackparams.x;

            // depth test and discard if it fails
            @(if (>= (strstr $arg1 "depth") 0) [result [
                if(dist > maxdist) discard;
            ]])

            if(output.a == accum.a)
            {   // no change in source pixel distance, must be inside
                @(if (>= (strstr $arg1 "depth") 0) [result [
                    discard;
                ]] [result [
                    if(dist <= maxdist) discard;
                    output = mix(output, accum, haloinfill.x);
                    output *= vec4(haloinfill.y, haloinfill.y, haloinfill.y, haloinfill.z);
                ]])
            }
            else
            { // outline
                output = mix(output, accum, halooutline.x);

                if(halooutline.w > 0.0)
                    output = mix(output, getsample(tex0, texcoord0, ivec2(1, -1), level), halooutline.w);

                output *= vec4(halooutline.y, halooutline.y, halooutline.y, halooutline.z);
            }

            if(halonoise.y > 0.0) output.rgb = mix(output.rgb, output.rgb * rand(texcoord0 + level), halonoise.y);
            if(halonoise.z > 0.0) output.a = mix(output.a, output.a * rand(vec2(texcoord0 - level)), halonoise.z);

            fragcolor = output * colorscale;
        }
    ]
]
hudhalo "hudhalodepth"
hudhalo "hudhalotop"

