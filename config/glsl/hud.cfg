///////////////////////////////////////////////////
//
// used for rendering to the HUD
//
///////////////////////////////////////////////////

shader 0 "hudrgb" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0;
        colorscale = vcolor;
    }
] [
    uniform sampler2D tex0;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    fragdata(0) vec4 fragcolor;
    void main(void)
    {
        vec4 color = texture2D(tex0, texcoord0);
        fragcolor.rgb = colorscale.rgb * color.rgb;
        fragcolor.a   = colorscale.a;
    }
]

shader 0 "hudrect" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0;
        colorscale = vcolor;
    }
] [
    uniform sampler2DRect tex0;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    fragdata(0) vec4 fragcolor;
    void main(void)
    {
        fragcolor = colorscale * texture2DRect(tex0, texcoord0);
    }
]

hudvisor = [
    shader 0 $arg1 [
        attribute vec4 vvertex, vcolor;
        attribute vec2 vtexcoord0;
        uniform mat4 hudmatrix;
        varying vec2 texcoord0;
        varying vec4 colorscale;
        void main(void)
        {
            gl_Position = hudmatrix * vvertex;
            texcoord0 = vtexcoord0;
            colorscale = vcolor;
        }
    ] [
        uniform sampler2DRect tex0;
        uniform float time;
        @(? (>= (strstr $arg1 "view") 0) [
            uniform vec4 visorparams;
        ])
        uniform vec4 visorsize;
        uniform vec3 visorglitch;
        varying vec2 texcoord0;
        varying vec4 colorscale;

        fragdata(0) vec4 fragcolor;

        float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233)))*43758.5453); }

        void main(void)
        {
            vec2 uv = texcoord0.xy;
            vec4 diffuse = vec4(0.0);

            @(if (>= (strstr $arg1 "view") 0) [result [
                // WARNING: This program MUST produce the same
                // results as the engine 'visorcoords()' for cursor projection

                uv *= visorsize.zw;

                uv -= vec2(0.5);
                uv *= visorparams.zw;

                float l = length(uv);
                uv.xy *= (1.0 + visorparams.x * visorparams.y * visorparams.y);
                uv.xy /= (1.0 + visorparams.x + l * l);

                uv += vec2(0.5);

                uv *= visorsize.xy;
            ]])

            diffuse = texture2DRect(tex0, uv);

            if(diffuse.a == 0.0) discard;

            float glitch = rand(vec2(uv.x, uv.y + (rand(vec2(time)) - 0.5) / 16.0)) * visorglitch.y;
            diffuse.rgb = mix(diffuse.rgb, vec3(glitch), glitch * visorglitch.x * visorglitch.z);

            fragcolor = colorscale * diffuse;
        }
    ]
]

hudvisor "hudvisor"
hudvisor "hudvisorview"

shader 0 "hud2d" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0;
        colorscale = vcolor;
    }
] [
    uniform sampler2D tex0;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    fragdata(0) vec4 fragcolor;
    void main(void)
    {
        fragcolor = colorscale * texture2D(tex0, texcoord0);
    }
]

shader 0 "hud3d" [
    attribute vec4 vvertex, vcolor;
    attribute vec3 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec3 texcoord0;
    varying vec4 color;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0;
        color = vcolor;
    }
] [
    uniform sampler3D tex0;
    varying vec3 texcoord0;
    varying vec4 color;
    fragdata(0) vec4 fragcolor;
    void main(void)
    {
        fragcolor = color * texture3D(tex0, texcoord0);
    }
]

shader 0 "hudcubemap" [
    attribute vec4 vvertex, vcolor;
    attribute vec3 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec3 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0;
        colorscale = vcolor;
    }
] [
    uniform samplerCube tex0;
    varying vec3 texcoord0;
    varying vec4 colorscale;
    fragdata(0) vec4 fragcolor;
    void main(void)
    {
        fragcolor = colorscale * textureCube(tex0, texcoord0);
    }
]

shader 0 "huddamage" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    varying vec2 pos;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        pos = vvertex.xy;
        texcoord0 = vtexcoord0;
        colorscale = vcolor;
    }
] [
    uniform float time;
    uniform vec3 speed;
    uniform vec3 colour;
    uniform sampler2D tex0; // mask
    uniform sampler2D tex1; // mixer

    varying vec2 texcoord0;
    varying vec4 colorscale;
    varying vec2 pos;
    fragdata(0) vec4 fragcolor;

    float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233)))*43758.5453); }

    void main(void)
    {
        vec4 mask = texture2D(tex0, texcoord0);
        if(mask.a == 0.0) discard;
        vec4 mixer = texture2D(tex1, vec2(pos.x, pos.y+time*speed.x));
        mixer += texture2D(tex1, vec2(pos.x+0.33, pos.y+time*speed.y));
        if(speed.z != 0.0)
        {
            float distort = rand(vec2(pos.y, pos.y+(rand(vec2(time))-0.5)/16.0))*speed.z;
            fragcolor.rgb = mix(distort, mixer.r, mixer.a)*colour.rgb*colorscale.rgb;
            fragcolor.a = mask.a*colorscale.a;
        }
        else
        {
            mixer.a *= 0.5;
            if(mixer.a == 0.0) discard;
            fragcolor.rgb = mixer.r*colour.rgb*colorscale.rgb;
            fragcolor.a = mixer.a*mask.a*colorscale.a;
        }
    }
]

hudhalo = [
    shader 0 $arg1 [
        attribute vec4 vvertex, vcolor;
        attribute vec2 vtexcoord0;
        uniform mat4 hudmatrix;
        varying vec2 texcoord0;
        varying vec4 colorscale;

        void main(void)
        {
            gl_Position = hudmatrix * vvertex;
            texcoord0 = vtexcoord0;
            colorscale = vec4(vcolor.rgb * vcolor.a, vcolor.a);
        }
    ] [
        uniform sampler2DRect tex0;
        uniform vec4 haloparams;
        varying vec2 texcoord0;
        varying vec4 colorscale;
        @(gfetchdefs [tex1])

        fragdata(0) vec4 fragcolor;

        void main(void)
        {
            vec4 halo = texture2DRectOffset(tex0, texcoord0, ivec2(0.0, 0.0));
            if(halo.a == 0.0) discard; // source pixel sucks

            float halo1 = texture2DRectOffset(tex0, texcoord0, ivec2(@[halooffset], @[halooffset])).a;
            float halo2 = texture2DRectOffset(tex0, texcoord0, ivec2(@[halooffset], -@[halooffset])).a;
            float halo3 = texture2DRectOffset(tex0, texcoord0, ivec2(-@[halooffset], @[halooffset])).a;
            float halo4 = texture2DRectOffset(tex0, texcoord0, ivec2(-@[halooffset], -@[halooffset])).a;

            float alpha = halo.a;
            @(loopconcat i 4 [
                j = (+ $i 1)
                result [
                    if(halo@[j] == halo.a) alpha += halo@[j];
                    alpha *= 0.5;
                ]
            ])

            // convert alpha back to distance
            float dist = (1.0 - alpha) * haloparams.z;

            // extract the depth information from the scene
            @(gdepthunpack depth [gfetch(tex1, gl_FragCoord.xy)])
            float maxdist = -depth;
            if(maxdist <= 0) maxdist = -gdepthunpackparams.x;

            // depth test and discard if it fails
            @(if (>= (strstr $arg1 "depth") 0) [result [
                if(dist > maxdist) discard;
            ]])

            vec4 diffuse = vec4(0.0);
            if(alpha == halo.a)
            {   // no change in source pixel distance, must be inside
                @(if (>= (strstr $arg1 "depth") 0) [result [
                    discard;
                ]] [result [
                    if(dist > maxdist) diffuse = halo * haloparams.y;
                    else discard;
                ]])
            }
            else diffuse = halo * clamp(alpha / halo.a * haloparams.x, 0.0, 1.0);

            fragcolor = colorscale * diffuse;
        }
    ]
]
hudhalo "hudhalodepth"
hudhalo "hudhalotop"

